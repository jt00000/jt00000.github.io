---
layout: page
title: "5月まとめ"
date: 2020-05-1 00:00:00 -0000
categories: pwn, other 
---
### rctf2020, pwn2win2020
- (5/30-31)２日で１０時間くらい。pwnを簡単なやつ２つ、crypto１つくらい。orangeの復習が生きたのが嬉しい。そろそろqemuで動く問題を時間内に解いてみたいなあ
    - pwn2win, tukro: fcloseからのio_flush_all_lockpを狙う問題で、mallocが0x500しかないがuafがある。io_list_allに放り込めたところで小さいチャンクが作れないからだめだなって思ってたけど、いくつかlargebinに放り込んだあと、0x60のチャンクを適当に作って間に突っ込んだら上手く動いた。
    - pwn2win, s1protocol: revなんだけど、static stripの取扱が深刻になってきた。defconの復習が生きてエラー文を探してライブラリは特定したけど、結局どの関数が何なのって言うの、ほとんどわからなかった。ライブラリを取得して、staticでコンパイルして、バイナリの形を眺めるみたいなのがいいのかなあ。みんなどうしてるんだろう。

### defcon qual2020
- (5/16-17)2日ほぼすべての時間を使って1問も解けなかった。さすがにびっくり。答えを一通り眺めたので片っ端から復習中。触ったところ、詰まったところは以下。
    - fountain-ooo-reliving：conway gameに俺はたどり着けなかったけど他の人が気づいて、gollyで見るところまでは行ったけど、その後の絵が回路図に見えなかったのがまずかった。（構成図っぽく見てた。）最後セルに気づいて色分けはしたけど、QRコードとかascii埋まってんだろくらいで舐めてた。
    - whooo-are-you：気合い入れて落としたのに人海戦術系でウケた。
    - babymaze：ようやくさわれそうなのが来てたんだけどまじで何も分からん。とりあえずptraceが分からないのをどうにかする。
    - fungez：aarchのkernel問だけど、VMっぽいコードになってて、フラグ入れて成功したらみたいな感じで一問目はREなのと思っていたがどちらにしてもデバッグのしかたが分からなすぎた。
    - moodem：何かモデムのなにかなんだろうなと思っていたが、読むためのツールがわからないため、バイト列を眺めて終了
    - uploooadit：シンプルすぎるのでさすがに行けるかと思ったがこれも何も分からんかった。ホワイトリストの正規表現マッチングってwriteupあさっても全然出てこなかった。
        - リクエストスマグリングという手法でフロントの解釈と後ろのサーバに投げる部分の解釈をずらすらしい。content−lengthとその下のヘッダで矛盾した内容にすることで実現して、そのズレを認識するとフラグが現れる？これのフラグが出てくるのまじで仕組みが分からん。
    - introool：公式ツイッタで雑魚でもできるって書いてあったからがんばってたら他の人が取っちゃった。どちらにしてもまず、最後の選択肢でbase64出てくるところまで行けてなかったので、我慢が足りんかった。
    - cursed：pwn問だったんだけどstaticのstripで最初何していいのか分からなすぎて死。これはかなり素直なバイナリで、落ち着いていたらもう少しだけ進めることができたはず。解けることはないが。
        - 参考：https://nankeen.me/post/defcon-quals-2020-cursed/
        - 最初にpowがあって、`blake2b`というハッシュが使われているのを謎の関数内部のエラー文から判断する。最初に表示された0x10バイトの文字列と0x30バイトの任意の文字列で、上位桁側３バイトが０であるような入力を求める。サーバ側で通るのを確認して、ローカルではnopで潰して解析を進める。
        - この後はcloneで別のスレッドが立ち上がって、`flag`と`bozo.bin`をロードして、フラグを立ててから実行する。メインスレッドでは0x1000バイトを受けて、フラグが立つのを待ってそれを実行する。forkは別プロセス、cloneは同一プロセス（豆）
        - とりあえず`bozo.bin`が無いので取りに行く。r13に入力列のアドレスがあって、その上側0x1000に`bozo.bin`が展開されているのでそこをwriteで表示させる。中身をダンプして解析したところ、フラグの情報はxmm0~7レジスタに格納してほかのメモリからは消す。そのあとxmmをバイト単位で後ろから確認して、合っていれば関数に飛んで、入力されたシェルコードをランダムに上書きして壊す。
        - ripが取れるなら、例えば時間ベースで読み出してもいいが、powが強めなのを考えるに時間的に現実的でない。結局別スレッドのxmmを読み出せれば良いので、別スレッドの関数呼び出しのリターンアドレスを書き換えるraceをやって、別プロセスに、こちらが入力したシェルコードに飛んでもらう。書き換えで別プロセス用のシェルコードがやられて無ければフラグが表示される。
        - まっとうな想定解法っぽいルートに沿っていきながら、最後はraceに持っていく発想力があるかどうか。あとはstripの関数判定について、IDAの機能を使ってるみたいなので、代替が欲しい。

### SANS miniwars mission3
- (5/15)AM2:00-10:00という鬼畜日程、長く休みを取っていたので試しに参加してみた。
    - 筋トレ感のある問題が多数。scapyの勉強になった。
    - 2:00に鯖落ち、3:30にようやくつながるもほとんどの問題がつながるけど立ち上がらない状態が続いてログインガチャ感あった
    - 大問５つ、完答３つで、残ったのはhttp3に対応する設定が言われたとおりにやってもできなかったこと、ゲームチート系の問題がさっぱりだったこと。これって答え出回るのかな。見たこと無いけど

### sharkCTF2020
- (5/9)同時開催のspamandflagsはむちゃくちゃ難しかったので置き。ブラウザ童貞なんとかしたいな。
    - pwn3くらい、あとcrypto, web, forens簡単なやつを適当。pwnは簡単回だった。
    - やっててできなかったのがpentestのやつ。色々やったけどpngのアップロードからのリサイズ後にrce用のペイロードを残せない。blog.phpから何か見れるのか。
    - メモリダンプの問題はビルドが必要らしいけどiso落とせなくて諦め。OSはCentOS7.8っぽいけどあってたのかな。
    - block chainは3問目のハッシュの評価式のやつ。phpの問題で似たようなのあったような。

### de1CTF2020
- (5/2)pwn1, misc1だけ
    - mipsバイナリがふってくるやつはヘッドレスのghidraでデコンパイルして真面目に解いてみたけどだめ。解析に３０秒位かかって、シェル走らすには時間が0.1秒切らないとだめなので解法が分からん。結局アセンブラから即値を取り出すのが正解だったらしい。mips見たくない病がだめ
    - revのparserも１０時間くらいかけたけど、＋と＿の処理がそれぞれ長過ぎるのと、結局合うハッシュが分からんというところで詰んだ。これは行けそうだったけどなあ。悔しい

### 常設
- (5/1) xyz全部解けました。vm問2問目がめっちゃ難しい。
- (5/4) pwnable_twのbookwriterのカンニング。house of orange問見つけた。no-pieでlibc2.23。かなり丁寧なwriteup：https://sunichi.github.io/2018/07/02/pwnable-tw-bookwriter/
    - 最初にトップチャンク小さくしてunsortbin作るところで意味が分かっていなくて。説明によると、トップチャンクを0xfe1にして、サイズ0x1000で取るとトップが小さいからsysmallocが動いて、0xfe1はfreeされるという話になっている。
    - この話が正しいならべつに0xfe1でなくてもfreeは通るはず。実際には通らない。0xff1、0xfd1、0xee1とか0xe1とか0x1とかは全部落ちた。調べると以下の条件で落ちてる。

    https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L2391
    ```
      assert ((old_top == initial_top (av) && old_size == 0) ||
          ((unsigned long) (old_size) >= MINSIZE &&
           prev_inuse (old_top) &&
           ((unsigned long) old_end & (pagesize - 1)) == 0));
    ```
    - コメントには、sysmallocが一度目じゃないならトップチャンクのサイズはMINSIZEよりでかいはずだし、prev_inuseは付いてるはずと記載されているので、そういう処理をしているはず。確認する。
        - old_top：今のトップチャンクのアドレス
        - old_size：今のトップチャンクのサイズ
        - prev_inuse：サイズ & 1のビットのこと
        - old_end：(char *)old_top + old_size、トップチャンクの終端のアドレス？
    - assertの条件一覧
        - (old_top == initial_top (av) && old_size == 0)
            - こっちが多分初回判定をする方のはず。
        - ((unsigned long) (old_size) >= MINSIZE &&
           prev_inuse (old_top) &&
           ((unsigned long) old_end & (pagesize - 1)) == 0))
            - サイズがMINSIZE（0x1f)より大きいかつ、inuseが真かつend & 0xfffがヌル
            - 要するにアライメントがあってないと死ぬ。
    - いまtopがheap+0x20なので、+0xfe1で下3ニブルが000でそろう。（prev_inuseは除いて）
    - 0xfe1は最小単位ということ。試すとしたら、トップを0x1fe1にして0x2000とっても異常は無いはず。上手く行った。
    - 次にip取る方法が、orangeさんのアレで、よく分かっていない部分。何となく眺めてると、abortがIO_flush_all_lockpをよんで、ファイル構造体の関数ポインタに飛ぶのでそれを差し替えて置く。
    - 肝心の差し替え方は、IO_list_allというやつがいて、IO_flush_all_lockpはそこのポインタのファイル構造体を参照してoverflow呼んで、chainについてる次の構造体を参照してoverflow呼んでっていうふうに処理が進む。
    - この時IO_list_allを直接書き換えられるのがベストだけどできなくて、代わりにunsortbin attackの要領でmain_arenaのアドレスが入ってしまう。
    - 一見使えなそうに見えるが、チャンクサイズを調整することで、main_arena->file->_chainにヒープアドレスが現れる。これはやばい。各ファイル構造体はそれぞれの_modeが0より小さかったらoverflowが呼ばれるが、そうでなければ_chainを見に行って同様の動作をするため、次のファイル構造体であるヒープの偽チャンクで発火するという仕組み。
    - ローカルではなぜか、_chainに進む前の構造体でoverflowが呼ばれてしまう現象に遭遇。
        - IO_flush_all_lockpでoverflowが呼ばれる条件は２つ

        ```
        if (((fp->_mode <= 0 && fp->_IO_write_ptr >   fp->_IO_write_base)
        #if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
	    || (_IO_vtable_offset (fp) == 0
	       && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr > p->_wide_data->_IO_write_base))
        ```

        - (5/5) ローカルで落ちる原因が判明。main_arenaがファイル構造体になってる時の_modeが正になってるときに条件を満たして入っちゃうことが理由になってて、ちょうど1/2で、libcアドレス&0x80000000が非ゼロだとoverflowを呼ばず、_chainに処理が進む。
        - 次に提供されたlibcのオフセットに調整する。2.23とあるものの、UBUNTU16のlibcとハッシュが合わないため、別のものになっていて、アドレスが若干変わっている。main_arenaのアドレス、IO_list_allのアドレス、0x60サイズが繋がれるunsotedbinのアドレスを変更する。abortのなかのbactraceを表示させるためにlibgccをロードするっぽいけど、これをやるdl_catch_errorの呼び出しでldファイルがずれてて隣のdl_debug_printfが呼ばれて死ぬ。提供されたlibcが知らない子だった場合詰んでるな。
    - (5/14) 元ネタの問題拾ったので復習がてら解いてみた。top揃えて１０００で取って、libcリーク、smallbinで確保して文字埋めてheapリーク、後は同じようにして解けた。
        - ついでに2.27でもやってみたけど、abort -> fflushがなくなってるのでだめっぽい。vtableチェックが動くので止める方はfclose問だった。これでも結局_IO_list_allの改ざんまでは行ってるから、IO_list_allにぶら下がる関数ポインタを動かすようなトリガーがあったら依然刺さっちゃうんだろうな。

- (5/7) zeroptsctf復習
    - カーネル問、systemで落ちて、execveで引数ヌルにしないと通る。gnoteのときにはsysretを使って、そのときはrcxとr11にセットして飛ばした気がするんだけど、違う戻り方をしている。仕組みを調べないといけない。どうやるもんなんだこれ。知識を増やすのがすごく難しい。
        - kpti bypassが4.15からで、この戻り方はその正常動作のところを沿っているだけ。それ以前はsysretかiret使えば良くて、レジスタの置き方が違うだけで役割は似ている。後ろにqがついたら64bitで戻れる。ユーザランド帰還後のシステムコールで__audit_syscall_entryかなんかが出て落ちたら、cc(pkc(0))のあとに__audit_sysall_exitを仕込む。
    - syscall kit、理解はできたがリークパートだけ見てもexploit組めなかった。クソいい問題。簡単に見えて解けないっていうのが自分に最適な難易度だと思う。

- (5/15)`scanf('%u', hoge)`は数字じゃないとバッファをいじらないのに気づかない定期になってきた（半年ぶり2度目）。scanfもう許さないぞ。
