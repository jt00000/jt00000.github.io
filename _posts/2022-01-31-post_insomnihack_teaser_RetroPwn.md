---
layout: page
title: "insomnihack teaser RetroPwn"
date: 2022-01-30 00:00:00 -0000
---

ひょんなことから異常に強いチームに入ってしまい、11月あたりからガチで1問も寄与できておらず、震えています。これは、そんな焦りからか睡眠や育児を時々放置しながら、24時間の競技時間のCTFに挑戦した人の物語。(なお時間内に解けてない。この記事は競技時間を終えた後、一連のタスクをやり終えた後に書いたものです。)

# 問題概要
ゲームボーイのバイナリと、telnetのアドレスが与えられます。

チームメンバーからは、[エミュレータ](https://bgb.bircd.org/)と[ディスアセンブラ](https://github.com/mattcurrie/mgbdis)を紹介されました。ゲームボーイ問は初見でしたが、面白そうだったのでやってみました。

ゲームの内容は、弾を打ってくる敵と、自キャラが存在します。自キャラはBボタンで弾を撃てて、敵を倒すとGOLDが入ります。（1GOLD）SCOREはアイテムを使って増やします。SCOREが上がるほど敵の弾の速度が増えます。倒すとSCOREの分だけGOLDが手に入ります。

![](/asset/20220131/2022-01-30-23-43-56.png)

アイテムメニューはStartボタンで開けて、GOLDを消費してPOINTに変えられます。変えたPOINTはUSEかTOSS（捨てる？）かを選べて、USEにするとこれがSCOREに変換されます。その他、HINTやLUCKなどありますが、全部必要GOLDが3桁くらいで高く、まじめにやるならかなりの数の敵を倒し続ける必要があります。

![](/asset/20220131/2022-01-30-23-44-17.png)

こちらは買ったアイテムをUSEするかTOSSするかを決められる画面。上の1行が微妙に変わります。右矢印キーでTOSSの数を選択できます。これは分かりにくかった。

![](/asset/20220131/2022-01-30-23-51-28.png)

しばらくディスアセンブラやデバッガをにらめっこしてかなりの時間プレイしましたが、これと言ってバグは見つけられません。

一方で、フラグはバイナリの中に埋まっていてどこからも参照されていないこと。printfのような関数が`2434`にあるのも確認したので、この問題がどうにかしてフラグの文字列のアドレスをprintfに入れる必要があるということは掴みました。

数字に絡んだ処理はこの個数の部分にしかなかったので、TOSSの機能で遊んでいるときに見つけました。増殖バグです。TOSSに所持している1つのPOINTをスタックした後、USEしてからTOSSすると、USEで一つ減っているにもかかわらずTOSSでさらに減らして255になります。これを利用して、SCOREを適当に増やす→100POINTをアンロックして個数を増やす、と続けることで、所持金の問題を解決しました。

気になるHINTやLUCKたち。結局Try harderとか言われて煽られるだけであまり役に立ちません。ここも詰まりましたが、少しガチャガチャやっていると、USEとTOSSの画面でカーソルが消えることに気づきます。個数を255で止めると、境界チェックが壊れてアイテムメニューの外側を参照できていました。TOSSを使うことで、ストックの配列の先にあるいくつかの値を好きに減らすことができました。ストック配列の先を確認します。

ストック配列は以下の`c3b0`から14バイト分がそれぞれうえからのストック数になっています。以下の例だと、1POINTが1ストックあることが分かります。続く `87 57 02 58 ...`は、スコアの表示をする関数のアドレスです。ディスアセンブラで出てこなかったのは、起動時に動的にテーブルがここに作られるためでした。調べると、`5787`は1POINTのUSEをしたときに使われる関数でした。ストック配列のOOBは結果的に関数テーブルのアドレスを好きに減算できるという状態になっています。便利ですね。

![](/asset/20220131/2022-01-31-00-04-22.png)

ただし制限があって、ストック配列は符号付きで判定されているようで、MSBが立っているとスキップされてしまいます。上記だと`87 57 ...`のうち87が飛んで、57から始まります。ちょっと使いにくいです。

飛び先を探しますが、都合よくスタックにフラグのアドレスを入れてくれるようなところが見つかりません。幸いメモリ保護はないそうなので、コードを自分で書けば良さそうです。減算バグは面倒な制限がありますが、`c3b0`からの14バイトは、増殖バグのおかげで好きに値になります。これを使って以下のようにして、フラグを書くコードを埋めます。

```
11 82 6d:   ld de, 0x6d82 <- フラグのアドレス
d5:         push de
cd 34 24:   call 2434 <- スタックのアドレスの文字列を表示する
18 f5:      jp $ - 11 <- 無限ループ（文字列を消す命令埋められなかったため、続けて何度も表示する必要があった。少し戻りすぎたが上は全部nopなので問題なし。）
```

実際に配置するとこのようになります。延々連打することになり少々しんどいです。

![](/asset/20220131/2022-01-31-00-48-28.png)

満足したところで一番の問題は、どのようにipを向けるかです。関数テーブルは全員5xで始まっていて、減算しかできないため、この`c3xx`というアドレスに向けることはできません。

c1xxあたりからnopでつながっているので、この辺に飛んでくれそうなガジェットを探しますが、良さそうなのが見つかりません。例えば3dbには`c3xx`に直接飛ぶガジェットがいましたが、dbという数字を作ることができないため不採用でした。

疲れてデバッガを眺めると、スタックに答えがありました。このデバッガはご丁寧にアドレス高位を上側に配置していたため、使えないなとしばらく思っていて、時間が無駄になっていました。

![](/asset/20220131/2022-01-31-00-22-14.png)

関数テーブルが呼ばれるときはDEE9にスタックがあるので、+0aするガジェットがあれば終わりです。
grepで探してみると、かなり都合の良いガジェットが`5587`で見つかります。関数テーブルの先頭のアドレスは`5787`なので、2回引けばよいです。

![](/asset/20220131/2022-01-31-00-24-00.png)

これで1POINTのUSEからスタックピボットしてストック配列上のコードを走ってくれます。スクリーンショットだとフラグが平和に表示されますが、実際は無限ループしたので見えない速さで回り続けています。

![](/asset/20220131/2022-01-31-00-33-06.png)

こちらが本番バージョンで、表示がミスってないならこれがフラグでしょう（読めない）
![](/asset/20220131/2022-01-31-00-34-53.png)

割といろいろ見て、発見して試して上手くいったので楽しかったです。